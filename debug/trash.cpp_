extern "C" void main();
#ifdef _MSC_VER
#define NAKED __declspec(naked)
#define __attribute__(packed) __declspec(naked)
#define __asm__ __asm
#else
#define NAKED __attribute__((naked))
#endif
extern "C" void _start() {
    __asm__ __volatile__(
        "jmp main;"
        "hlt;"
    );
}
typedef unsigned short uint16_t;
typedef unsigned char uint8_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef signed short int16_t;
typedef signed char int8_t;
typedef signed int int32_t;
typedef signed long long int64_t;
typedef struct {
    uint64_t framebufferAddr;
    uint32_t framebufferWidth;
    uint32_t framebufferHeight;
    uint32_t framebufferPitch;
    void* rsdp;
} BootInfo;
typedef struct {
    uint64_t gbuffer;
    uint32_t width;
    uint32_t height;
} Frame;
static int seed = 123456789;
int simple_rand() {
    seed ^= seed << 13;
    seed ^= seed >> 17;
    seed ^= seed << 5;
    return seed;
}
#define KEY_ESC        (char)0x1B
#define KEY_RETURN     (char)0x0D
#define KEY_TAB        (char)0x09
#define KEY_BACKSPACE  (char)0x08
#define KEY_SPACE      (char)0x20
#define KEY_LSHIFT     (char)0xA0
#define KEY_RSHIFT     (char)0xA1
#define KEY_LCONTROL   (char)0xA2
#define KEY_RCONTROL   (char)0xA3
#define KEY_LMENU      (char)0xA4
#define KEY_RMENU      (char)0xA5
#define KEY_CAPITAL    (char)0x14
#define KEY_NUMLOCK    (char)0x90
#define KEY_SCROLL     (char)0x91
#define KEY_INSERT     (char)0x2D
#define KEY_DELETE     (char)0x2E
#define KEY_HOME       (char)0x24
#define KEY_END        (char)0x23
#define KEY_PAGEUP     (char)0x21
#define KEY_PAGEDOWN   (char)0x22
#define KEY_UP         (char)0x26
#define KEY_DOWN       (char)0x28
#define KEY_LEFT       (char)0x25
#define KEY_RIGHT      (char)0x27
#define KEY_F1         (char)0x70
#define KEY_F2         (char)0x71
#define KEY_F3         (char)0x72
#define KEY_F4         (char)0x73
#define KEY_F5         (char)0x74
#define KEY_F6         (char)0x75
#define KEY_F7         (char)0x76
#define KEY_F8         (char)0x77
#define KEY_F9         (char)0x78
#define KEY_F10        (char)0x79
#define KEY_F11        (char)0x7A
#define KEY_F12        (char)0x7B
#define KEY_PAUSE      (char)0x92
unsigned char font8x8_basic[128][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (;)
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};
char scan_code_table[] = {
    (char)0, KEY_ESC, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b',
    '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', KEY_RETURN,
    KEY_LCONTROL, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`',
    KEY_LSHIFT, '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', KEY_RSHIFT,
    KEY_RCONTROL, KEY_LMENU, ' ', (char)0, KEY_CAPITAL,
    KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10,
    KEY_F11, KEY_F12, (char)0, (char)0, (char)0, (char)0, (char)0, KEY_SCROLL, KEY_PAUSE, (char)0, (char)0, (char)0,
    KEY_INSERT, KEY_HOME, KEY_PAGEUP, (char)0, KEY_DELETE, KEY_END, KEY_PAGEDOWN, (char)0,
    KEY_UP, (char)0, KEY_LEFT, (char)0, KEY_RIGHT, (char)0, KEY_DOWN
};
volatile int kbd_state[256] = {
    0,
};
void outb(uint16_t port, uint8_t value) {
    __asm__ __volatile__(
        "mov dx, %0;"
        "mov al, %1;"
        "out dx, al;"
        :
    : "r" (port), "r" (value)
        : "dx", "al"
        );
}

static inline uint8_t inb(uint16_t port) {
    uint8_t ret;
    __asm__ __volatile__(
        "mov dx, %1;"
        "xor eax, eax;"
        "in al, dx;"
        "mov %0, al;"
        : "=r" (ret)
        : "r" (port)
        : "eax", "edx"
    );
    return ret;
}
void putc(volatile Frame& f, int x, int y, char text, uint32_t color, int scale) {
    if (text < 32 || text > 127) return;
    for (int row = 0; row < 8; row++) {
        uint8_t bits = font8x8_basic[(int)text][row];
        for (int col = 0; col < 8; col++) {
            if (bits & (1 << col)) {
                for (int y_offset = 0; y_offset < scale * 2; y_offset++) {
                    for (int x_offset = 0; x_offset < scale; x_offset++) {
                        ((uint32_t*)(f.gbuffer))[(int)f.width * (y + row * scale * 2 + y_offset) + (x + col * scale + x_offset)] = color;
                    }
                }
            }
        }
    }
}
#define PIC1_CMD  0x20
#define PIC1_DATA 0x21
#define KEYBOARD_DATA_PORT 0x60

#define IDT_SIZE 256
struct idt_entry {
    uint16_t offset_low;
    uint16_t selector;
    uint8_t zero;
    uint8_t type_attr;
    uint16_t offset_middle;
    uint32_t offset_high;
    uint32_t reserved;
} __attribute__((packed));

struct idt_ptr {
    uint16_t limit;
    uint64_t base;
} __attribute__((packed));
idt_entry idt[IDT_SIZE] __attribute__((aligned(16)));
idt_ptr idt_reg;
void set_idt_gate(int n, uint64_t handler, uint16_t selector, uint8_t flags) {
    idt[n].offset_low = handler & 0xFFFF;
    idt[n].offset_middle = (handler >> 16) & 0xFFFF;
    idt[n].offset_high = (handler >> 32) & 0xFFFFFFFF;
    idt[n].selector = selector;
    idt[n].zero = 0;
    idt[n].type_attr = flags;
}
void load_idt(idt_ptr* _idt_ptr) {
    __asm__ __volatile__(
        "lidt [%0];"
        : : "r"(_idt_ptr) : "memory"
    );
}
void load_idt() {
    idt_reg.limit = (sizeof(struct idt_entry) * IDT_SIZE) - 1;
    idt_reg.base = (uint64_t)&idt;
    load_idt(&idt_reg);
}
int8_t inputbuffer[256] = { 0, };
uint8_t inputinbuff = 0;
uint8_t inputoutbuff = 0;
void inputtobuffer(int8_t* buffer, uint8_t& inbuff, uint8_t& outbuff, int8_t n) {
    if (inbuff + 1 == outbuff || (inbuff == 255 && outbuff == 0)) {
        return;
    }
    buffer[inbuff] = n;
    inbuff = (inbuff + 1) % 256;
}
int8_t outputtobuffer(int8_t* buffer, uint8_t& inbuff, uint8_t& outbuff) {
    if (inbuff == outbuff) {
        return 0;
    }
    int8_t result = buffer[outbuff];
    outbuff = (outbuff + 1) % 256;
    return result;
}
extern "C" void keyboard_handler() {
    __asm__ __volatile__(
        "cli;"
    );
    uint8_t scancode = inb(KEYBOARD_DATA_PORT);
    if (scancode == 0xe0) {
        scancode = inb(KEYBOARD_DATA_PORT);
    }
    if (scancode & 0x80) {
        scancode -= 0x80;
        kbd_state[scan_code_table[scancode]] = 0;
    }
    else {
        kbd_state[scan_code_table[scancode]] = 1;
        inputtobuffer(inputbuffer, inputinbuff, inputoutbuff, scan_code_table[scancode]);
    }
    //shutdown(gGraphicsInfo->rsdp);
    outb(PIC1_CMD, 0x20);
    __asm__ __volatile__(
        "leave;"
        "sti;"        // 인터럽트 활성화
        "iretq;"        // 인터럽트 종료
    );
}
int64_t timer = 0;

extern "C" void timer_handler() {
    __asm__ __volatile__(
        "cli;"
        "mov dx, 0x20;"
        "mov al, 0x20;"
        "out dx, al;"
        "leave;"
        "sti;"        // 인터럽트 활성화
        "iretq;"        // 인터럽트 종료
    );
}
extern "C" void none_handler() {
    outb(0xA0, 0x20); // 인터럽트 종료 신호
    outb(PIC1_CMD, 0x20);
    __asm__ __volatile__(
        "leave;"
        "nop;"
        "iretq;"        // 인터럽트 종료
    );
}
volatile int cursor_x = 200;
volatile int cursor_y = 200;
extern "C" void cursor_handler() {
    __asm__ __volatile__(
        "cli;"
    );
    static uint8_t cycle = 0;
    static uint8_t cursor_bytes[3];

    cursor_bytes[cycle] = inb(0x60);
    if (cycle == 0 && !(cursor_bytes[0] & 0x08));
    else if (++cycle == 3) { // 3바이트 패킷 수신 완료
        cycle = 0;

        uint8_t dx = cursor_bytes[1]; // X 이동 값
        uint8_t dy = cursor_bytes[2]; // Y 이동 값 (위-아래 반전)
        int8_t x_sign = (cursor_bytes[0] & 0x10) >> 4;  // X 부호 비트 (비트 3)
        int8_t y_sign = (cursor_bytes[0] & 0x20) >> 5;  // Y 부호 비트 (비트 4)
        if ((cursor_bytes[0] >> 6) & 1) cursor_x += x_sign ? -255 : 255;
        else if (x_sign) cursor_x -= (uint8_t)(dx * -1);
        else cursor_x += dx;

        if (cursor_bytes[0] >> 7) cursor_y += y_sign ? -255 : 255;
        else if (y_sign) cursor_y += (uint8_t)(dy * -1);
        else cursor_y -= dy;
        BootInfo* gGraphicsInfo = (BootInfo*)0x200000;
        if (cursor_x < 0) cursor_x = 0;
        if (cursor_y < 0) cursor_y = 0;
        if (cursor_x >= gGraphicsInfo->framebufferWidth) cursor_x = gGraphicsInfo->framebufferWidth - 1;
        if (cursor_y >= gGraphicsInfo->framebufferHeight) cursor_y = gGraphicsInfo->framebufferHeight - 1;
    }
    outb(0xA0, 0x20); // 인터럽트 종료 신호
    outb(0x20, 0x20); // 인터럽트 종료 신호
    __asm__ __volatile__(
        "leave;"
        "sti;"        // 인터럽트 활성화
        "iretq;"        // 인터럽트 종료
    );
}

// PS/2 컨트롤러에서 마우스 활성화 및 인터럽트 설정
void enable_cursor() {
    outb(0x64, 0xA8); // 마우스 활성화
    outb(0x64, 0x20);
    while ((inb(0x64) & 1) == 0); // 입력 버퍼가 비어 있을 때까지 기다림
    uint8_t status = inb(0x60) | 2;
    outb(0x64, 0x60);
    outb(0x60, status);

    // 마우스 설정
    outb(0x64, 0xD4); // 마우스 데이터 전송
    outb(0x60, 0xF4); // 마우스 데이터 전송 활성화
}
void init_pic() {
    outb(PIC1_CMD, 0x11);
    outb(0xA0, 0x11);
    outb(PIC1_DATA, 0x20);
    outb(0xA1, 0x28);
    outb(PIC1_DATA, 4);
    outb(0xA1, 2);
    outb(PIC1_DATA, 0x01);
    outb(0xA1, 0x01);
    outb(PIC1_DATA, 0x00);
    outb(0xA1, 0x00);
}
void init_interrupts() {
    asm volatile ("cli");
    init_pic();
    enable_cursor();
    for (int i = 0; i < IDT_SIZE; i++) {
        set_idt_gate(i, (uint64_t)none_handler, 0x08, 0x8E);
    }
    set_idt_gate(32, (uint64_t)timer_handler, 0x08, 0x8E);
    set_idt_gate(33, (uint64_t)keyboard_handler, 0x08, 0x8E);
    set_idt_gate(44, (uint64_t)cursor_handler, 0x08, 0x8E);
    load_idt();
    asm volatile ("sti");
}
uint8_t console[80 * 40] = { 0, };
extern "C" void main() {
    unsigned int i;
    int y;
    int x;
    for (i = 0; i < 256; i++) {
        inputbuffer[i] = 0;
    }
    init_interrupts();
    BootInfo* gGraphicsInfo = (BootInfo*)0x200000;
    for (i = 0; i < gGraphicsInfo->framebufferWidth * gGraphicsInfo->framebufferHeight; i++) {
        uint8_t Red = 255;
        uint8_t Green = 255;
        uint8_t Blue = 255;

        uint32_t PixelColor = (Red << 16) | (Green << 8) | Blue;
        *((uint32_t*)(gGraphicsInfo->framebufferAddr) + i) = PixelColor;
    }
    Frame mainframe = { gGraphicsInfo->framebufferAddr,gGraphicsInfo->framebufferWidth,gGraphicsInfo->framebufferHeight };
    int console_x = 0;
    int console_y = 0;
    while (1) {
        for (i = 0; i < mainframe.width * mainframe.height; i++) {
            *((uint32_t*)(mainframe.gbuffer) + i) = -1u;
        }
        for (y = 0; y < 35; y++) {
            for (x = 0; x < 25; x++) {
                if (x <= y && cursor_x + x >= 0 && cursor_x + x < gGraphicsInfo->framebufferWidth && cursor_y + y >= 0 && cursor_y + y < gGraphicsInfo->framebufferHeight) {
                    ((uint32_t*)(mainframe.gbuffer))[(int)gGraphicsInfo->framebufferWidth * (cursor_y + y) + (cursor_x + x)] = 0;
                }
            }
        }
        console[console_y * 80 + console_x] = outputtobuffer(inputbuffer, inputinbuff, inputoutbuff);
        if (console[console_y * 80 + console_x] != 0) {
            console_x++;
            if (console_x >= 80) {
                console_x = 0;
                console_y += 1;
            }
        }
        for (y = 0; y < 40; y++) {
            for (x = 0; x < 80; x++) {
                putc(mainframe, x * 2 * 8 + 4, y * 2 * 16 + 4, console[y * 80 + x], 0, 2);
            }
        }
        /*
        for (i = 0; i < gGraphicsInfo->framebufferWidth * gGraphicsInfo->framebufferHeight; i++) {
            *((uint32_t*)(gGraphicsInfo->framebufferAddr) + i) = *((uint32_t*)(0x500000) + i);
        }
        */
    }
}